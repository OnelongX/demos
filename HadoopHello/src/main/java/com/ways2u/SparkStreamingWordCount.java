package com.ways2u;

import scala.Tuple2;

import org.apache.spark.SparkConf;    
import org.apache.spark.api.java.function.FlatMapFunction;    
import org.apache.spark.api.java.function.Function2;    
import org.apache.spark.api.java.function.PairFunction;    
import org.apache.spark.api.java.StorageLevels;    
import org.apache.spark.streaming.Durations;    
import org.apache.spark.streaming.api.java.JavaDStream;    
import org.apache.spark.streaming.api.java.JavaPairDStream;    
import org.apache.spark.streaming.api.java.JavaReceiverInputDStream;    
import org.apache.spark.streaming.api.java.JavaStreamingContext;

import java.util.Arrays;
import java.util.Iterator;
import java.util.regex.Pattern;


public final class SparkStreamingWordCount {
  //测试： nc -l 9999

 private static final Pattern SPACE = Pattern.compile(" ");    
 public static void main(String[] args) {    

   //StreamingExamples.setStreamingLogLevels();
   // Create the context with a 1 second batch size    
   SparkConf sparkConf = new SparkConf().setAppName("SparkStreamingWordCount").setMaster("local");

   JavaStreamingContext ssc = new JavaStreamingContext(sparkConf, Durations.seconds(10));
   // Create a JavaReceiverInputDStream on target ip:port and count the    
   // words in input stream of \n delimited text (eg. generated by 'nc')    
   // Note that no duplication in storage level only for running locally.    
   // Replication necessary in distributed scenario for fault tolerance.

   JavaReceiverInputDStream<String> lines = ssc.socketTextStream("localhost", 9999);


   JavaDStream<String> words = lines.flatMap(new FlatMapFunction<String, String>() {
       @Override
       public Iterator<String> call(String s) throws Exception {
         return Arrays.asList(SPACE.split(s)).iterator();
       }
     });


   JavaPairDStream<String, Integer> wordCounts = words.mapToPair(    
     new PairFunction<String, String, Integer>() {    
       @Override    
       public Tuple2<String, Integer> call(String s) {    
         return new Tuple2<String, Integer>(s, 1);    
       }    
     }).reduceByKey(new Function2<Integer, Integer, Integer>() {    
       @Override    
       public Integer call(Integer i1, Integer i2) {    
         return i1 + i2;    
       }    
     });

   wordCounts.print();    
   ssc.start();

   try {
     ssc.awaitTermination();
   } catch (InterruptedException e) {
     e.printStackTrace();
   }
 }    
}